# mocnpub - Nostr npub マイニングプロジェクト 🔥

**Last Updated**: 2025-11-22

このファイルには mocnpub プロジェクトの開発方針、技術選択、段階的アプローチが記載されています。

---

## 🎯 プロジェクト概要

**mocnpub** は、Nostr の npub マイニングプログラムです。

**目的**：
- かっこいい prefix を持つ npub（自分のほしい prefix）になる nsec を探す
- GPGPU（CUDA）を使って爆速マイニング 🚀

**背景**：
- Nostr の公開鍵（npub）は secp256k1 で生成される
- ランダムに生成すると、prefix は予測不可能
- 特定の prefix を持つ npub を見つけるには、大量の試行が必要
- GPGPU を使えば、CPU の何百倍も速くマイニングできる 💪

---

## 🛠️ 技術選択

### 言語：Rust 🦀

**選定理由**：
1. ✅ **WSL でも Windows でもビルド可能**（開発は WSL、実行は Windows native でパフォーマンス最大化）
2. ✅ **暗号ライブラリが豊富**（`secp256k1` の Rust バインディングがある）
3. ✅ **数年後も動く**（静的リンク、ランタイム不要）
4. ✅ **CUDA との連携が可能**（`cuda-sys`, `cudarc` などのクレート）
5. ✅ **メモリ安全**（セグフォで詰まりにくい）
6. ✅ **rana（参考プロジェクト）が Rust で書かれている**

**デメリット**：
- コンパイラが厳しい（でも、それがメリットにもなる）
- 学習曲線がある（でも、一緒に学びながら進める！）

### GPGPU：CUDA 🔥

**選定理由**：
1. ✅ **RTX 5070 Ti（NVIDIA）に最適**
2. ✅ **パフォーマンス最高**（NVIDIA 専用最適化）
3. ✅ **資料が豊富**（学習しやすい）
4. ✅ **暗号計算に強い**（マイニングに最適）

**他の選択肢との比較**：

| | CUDA | OpenCL | Vulkan Compute |
|---|---|---|---|
| **対応GPU** | NVIDIA のみ | すべて | すべて |
| **パフォーマンス** | 🔥 最高 | 🔥 良い | 🔥 良い |
| **学習難易度** | ⭐⭐⭐ 中 | ⭐⭐⭐⭐ やや難 | ⭐⭐⭐⭐⭐ 難 |
| **資料の豊富さ** | 🌟🌟🌟🌟🌟 超豊富 | 🌟🌟🌟 そこそこ | 🌟🌟 少ない |

**結論**：RTX 5070 Ti + 初学者 → CUDA 一択 💪

---

## 🚀 段階的アプローチ

**方針**：未知の分野を学びながら進めるため、段階的に実装します。

### Step 0: Rust + CUDA の Hello World 🌸
- CUDA ツールキットのインストール
- Rust + CUDA の開発環境セットアップ
- 最小限の CUDA プログラムで動作確認
- **目的**：「うちのパソコンじゃ動かなかった」を防ぐ

### Step 1: GPU で簡単なプログラム（動作確認）🔥
- マンデルブロ集合、または単純な計算（配列の足し算など）
- CUDA の基本を体感（カーネル、スレッド、メモリ管理）
- パフォーマンス測定
- **目的**：CUDA の仕組みを理解する

### Step 2: CPU 版 npub マイニング 💪
- `secp256k1` を学ぶ
- Nostr の鍵生成の仕組みを理解
- CLI インターフェース（clap クレート）
- 「prefix が一致する nsec を探す」ロジック
- **目的**：マイニングのアルゴリズムを理解する
- **完了**: 2025-11-22 ✅

### Step 2.5: CPU 版のブラッシュアップ 🔧
- マルチスレッド対応（全 CPU コアを活用）
- 継続モード（複数の鍵を見つける）
- 複数 prefix の OR 指定
- 入力検証（bech32 で使えない文字のチェック）
- テストコード・ベンチマーク作成
- **目的**：実用的な CPU 版マイナーを完成させる
- **詳細**: 下記「Step 2.5 詳細仕様」参照

### Step 3: GPU 版に移行 🚀
- CPU 版のロジックを GPU に移植
- パフォーマンス比較（CPU vs GPU）
- 最適化（メモリ転送、カーネル最適化）
- **目的**：爆速マイニングの完成 🔥

---

## 📚 開発方針

### 学びながら進める 🌸
- GPGPU は未知の分野
- Rust もほぼ初心者
- secp256k1 も初めて
- **焦らず、丁寧に、落穂拾いしながら進める** 💕

### 挫折しない工夫 💪
- 段階的アプローチ（小さな成功を積み重ねる）
- 動作確認を優先（まず動く、それから最適化）
- タスクリストで進捗を可視化
- セッション分割で焦らず進める

### ファイル管理方針 📂
- 学習用ファイルも git 管理に含める
- Step 0〜3 の学習過程もすべて記録
- npub マイナー以外のファイルも置く（マンデルブロ集合など）
- **プロジェクトの成長過程を大切に** 🌱

---

## 🔗 参考プロジェクト

### rana
- **URL**: https://github.com/grunch/rana
- **言語**: Rust
- **GPGPU**: CUDA
- **実績**: ユーザーさんが実際に動かして、正しい npub/nsec の組を見つけた 💪
- **参考価値**: 実装の参考に（完全にコピーするのではなく、学びながら自分で作る）
- **仕様参考**: 複数 prefix 指定（`--prefix=m0ctane0,m0ctane2,m0ctane3,m0ctane4`）

---

## 🔧 Step 2.5 詳細仕様

### 背景・目的

**Step 2（CPU 版 npub マイニング）が完了**（2025-11-22）🎉

**Phase 1 完了**（2025-11-22）✅：
- ✅ **マルチスレッド対応**：16スレッドで 80〜100万 keys/sec（12〜20倍高速化）
- ✅ **入力検証**：bech32 無効文字（1, b, i, o）を検出、事故を防ぐ

**Phase 1 完了時のエピソード** 💡：
- prefix "abc" が1億回試行しても見つからない謎が発生
- → もくたんさんの推理：「"b" は bech32 で無効な文字では？」
- → 大正解！入力検証の実装で今後は事故を防げる 🛡️

**残りの実装機能**：
- ✅ **テストコード**：品質保証（7つのテストケース、全てパス）
- ✅ **継続モード**：複数の鍵を見つける（std::sync::mpsc、append モード）
- **複数 prefix 指定**：欲しい prefix の組み合わせを探す ← **次はこれ！**
- **ベンチマーク**：パフォーマンス測定

GPU 版に移行する前に、CPU 版を実用レベルまでブラッシュアップします。

---

### 実装する機能

#### 1. マルチスレッド対応 🔥

**目的**：CPU の全コアを活用して、高速化

**仕様**：
- `--threads <N>` オプション：スレッド数を指定（デフォルト：自動検出）
- 各スレッドが独立して鍵生成 → マッチしたら共有キューに送信
- 進捗表示：全スレッドの合計試行回数を表示

**技術選択**：
- **std::thread** で実装（標準ライブラリのみ、外部クレート不要）
  - Arc + AtomicU64/AtomicBool でスレッド間通信
  - Mutex で結果を保護
  - タスク並列処理に最適

**実証された高速化**：
- 16スレッドで **12〜20倍の高速化**（80〜100万 keys/sec）
- CPU コア数に応じて線形に高速化

**rayon との比較**：
- rayon: データ並列処理（配列を並列に処理）
- std::thread: タスク並列処理（各スレッドが独立したタスク）
- 今回のマイニングは「タスク並列処理」なので、std::thread が最適

#### 2. 継続モード 💪 ✅ **完了！**（2025-11-23）

**目的**：複数の鍵を見つける（一晩動かす用途）

**仕様**：
- `--limit <N>` オプション：N個見つかったら終了（0 = 無限、デフォルト：1）
- 見つかるたびに、その場で出力（append モード）
- 停電で PC が落ちても、それまでの結果が残る

**実装の詳細**：
- **std::sync::mpsc で channel を使用**（標準ライブラリのみ）
  - ワーカースレッド → メインスレッドに結果を送信
  - 見つかるたびに channel 経由で送信・即座に出力
- **AtomicUsize で見つかった個数をカウント**
  - limit 個見つかったら全スレッド停止
- **OpenOptions::new().append(true) でファイル追記**
  - 1回目：新規作成、2回目以降：追記
  - 各出力は flush して、すぐにディスクに書き込み
- **進捗表示に「見つかった: N個」を追加**
  - 1秒ごとに試行回数と見つかった個数を表示

**出力フォーマット**：
- ファイル出力の場合：見つかるたびに append
- 標準出力の場合：見つかるたびに `println!`（ファイル出力と同時）

**例**：
```bash
# 10個見つかるまで実行
./mocnpub-main --prefix m0ctane --limit 10 --output results.txt

# 無限に実行（Ctrl+C で停止）
./mocnpub-main --prefix m0ctane --limit 0 --output results.txt
```

**テスト結果**：
- デフォルトモード（1個で終了）: ✅
- 継続モード（3個で終了）: ✅
- append モード（同じファイルに追記）: ✅

#### 3. 複数 prefix の OR 指定 🎯 ✅ **完了！**（2025-11-23）

**目的**：複数の prefix の組み合わせを探す

**仕様**：
- `--prefix <PREFIX1,PREFIX2,...>` オプション：カンマ区切りで複数指定
- どれか1つにマッチすればOK
- rana の仕様を参考に

**例**：
```bash
# 単一 prefix
./mocnpub-main --prefix "test"

# 複数 prefix（OR 指定）
./mocnpub-main --prefix "0,2,5"
./mocnpub-main --prefix "m0ctane0,m0ctane2,m0ctane3,m0ctane4"
```

**実装の詳細**：
- **prefix を split して Vec<String> に変換**（trim で空白除去）
- **Arc<Vec<String>> でスレッド間共有**
- **iter().find() でマッチング判定**
  - どれか1つにマッチすれば OK
  - matched_prefix を channel で送信
- **各 prefix に対して入力検証**
  - bech32 無効文字を検出
- **出力に「マッチした prefix」を表示**

**テスト結果**：
- ✅ 単一 prefix（既存の動作）
- ✅ 複数 prefix の OR 指定（"0,2,5" で3種類にマッチ）
- ✅ 入力検証（無効な文字 'b' を検出）
- ✅ trim() 動作（空白を正しく除去）

#### 4. 入力検証 🛡️

**目的**：bech32 で使えない文字を弾く

**bech32 で使えない文字**：
- `1`, `b`, `i`, `o`（混同を避けるため）
- 大文字（bech32 は小文字のみ）

**仕様**：
- 起動時に全ての prefix を検証
- 使えない文字が含まれていたら、エラーメッセージを表示して終了

**例**：
```bash
$ ./mocnpub-main --prefix m0ctane1
Error: Invalid prefix 'm0ctane1': bech32 does not allow '1'
Valid characters: 023456789acdefghjklmnpqrstuvwxyz
```

#### 5. CPU での高速化案 ⚡

**検討事項**：
- **bech32 変換 vs hex 比較**：どちらが速い？
  - 現在：secp256k1 → bech32 エンコード → prefix マッチング
  - 代替案：prefix を hex にデコード → バイト列比較
  - **結論**：bech32 は base32 + チェックサムなので、直接 hex 比較は困難
  - **現実的な高速化**：マルチスレッドが一番効果的

**その他の高速化**：
- bech32 エンコード自体の最適化は `bech32` クレートに任せる
- 将来的に bech32 エンコードがボトルネックになったら、カスタム実装を検討

#### 6. テストコード・ベンチマーク 🧪

**テストコード**（`#[test]`）：
- `pubkey_to_npub()` のテスト（既知の公開鍵 → 既知の npub）
- `seckey_to_nsec()` のテスト
- prefix 検証関数のテスト
- 複数 prefix マッチングのテスト

**ベンチマーク**（`cargo bench` + `criterion` クレート）：
- bech32 エンコードのパフォーマンス測定
- マルチスレッド vs シングルスレッドの比較
- prefix マッチングのパフォーマンス測定

---

### 実装の優先順位

**Phase 1（高優先度）** ✅ **完了！**（2025-11-22）：
1. **マルチスレッド対応** 🔥 ✅
   - 最も効果的な高速化
   - std::thread で実装（16スレッド）
   - 12〜20倍の高速化を実証（80〜100万 keys/sec）
2. **入力検証** 🛡️ ✅
   - ユーザー体験の向上
   - bech32 無効文字（1, b, i, o）を検出
   - ユーザーフレンドリーなエラーメッセージ

**Phase 2（中優先度）** ✅ **完了！**（2025-11-23）：
3. **テストコード** 🧪 ✅ **完了！**（2025-11-23 00:00〜00:11）
   - 7つのテストケースを実装（全てパス）
   - `validate_prefix()` のテスト（有効/無効文字/大文字/空文字/エラーメッセージ）
   - `pubkey_to_npub()` のテスト（bech32 変換の正確性）
   - `seckey_to_nsec()` のテスト（bech32 変換の正確性）
   - Rust のテスト文化：同じファイルに `#[cfg(test)]` モジュールを書くのが一般的
4. **継続モード** 💪 ✅ **完了！**（2025-11-23 00:18〜00:28）
   - `--limit <N>` オプション（0 = 無限、デフォルト: 1）
   - std::sync::mpsc で channel を使用（標準ライブラリのみ）
   - 見つかるたびに channel 経由で送信・即座に出力
   - OpenOptions::new().append(true) でファイル追記
   - 停電で PC が落ちても、それまでの結果が残る 🛡️
5. **複数 prefix の OR 指定** 🎯 ✅ **完了！**（2025-11-23 11:06〜11:13）
   - カンマ区切りで複数 prefix を指定可能
   - Vec<String> でシンプルに実装
   - iter().find() でマッチング判定
   - 出力に「マッチした prefix」を表示

**Phase 3（低優先度）** ✅ **完了！**（2025-11-23 11:49〜12:10）：
6. **ベンチマーク** 📊 ✅ **完了！**
   - criterion 0.6 クレートを使用
   - src/lib.rs を作成して、main.rs と benchmark.rs で共通関数を共有
   - 6つのベンチマークを実装（鍵生成、npub/nsec 変換、prefix マッチング、検証、完全なマイニングサイクル）
   - **ボトルネックは secp256k1 の鍵生成**（13.1 µs、全体の93%）
   - bech32 エンコードは 663 ns（約5%）と十分速い
   - prefix マッチングは 1.5 ns と超高速（ほぼ無視できる）
   - 完全なマイニングサイクル = 14.0 µs（理論上は約71,000 keys/sec）
   - **GPU 版での高速化が期待できる**（鍵生成を並列化すれば圧倒的な高速化が可能） 🚀

**ベンチマーク結果の詳細**：

| 項目 | 時間 | 割合 |
|------|------|------|
| 鍵生成（secp256k1） | 13.1 µs | 93% |
| npub 変換（bech32） | 663 ns | 5% |
| nsec 変換（bech32） | 229 ns | 2% |
| prefix マッチング | 1.5 ns | 0.01% |
| validate_prefix | 27 ns | 0.2% |
| **完全なマイニングサイクル** | **14.0 µs** | **100%** |

**Step 2.5 完全クリア！** 🎉
- Phase 1: マルチスレッド、入力検証 ✅
- Phase 2: テストコード、継続モード、複数 prefix の OR 指定 ✅
- Phase 3: ベンチマーク ✅
- **実用的な CPU 版マイナーが完成** 💪
- **GPU 版への移行準備が整った** 🚀

---

### 技術選択

**並列化**：
- **rayon** 0.8（データ並列処理）
- または **std::thread** + **crossbeam-channel** 0.5（より細かい制御）

**スレッド数の自動検出**：
- **num_cpus** 1.16（論理コア数を取得）

**テスト**：
- Rust 標準の `#[test]`

**ベンチマーク**：
- **criterion** 0.6（統計的に信頼できるベンチマーク）

---

### 実装時の注意点

**マルチスレッドの注意点**：
- `secp256k1::Secp256k1::new()` はスレッドごとに作成（または Arc で共有）
- 乱数生成器はスレッドごとに独立（`rand::thread_rng()`）
- 進捗表示は `AtomicU64` でスレッドセーフに

**継続モードの注意点**：
- ファイル出力は append モード（`OpenOptions::new().append(true)`）
- 各出力は atomic に（1つの鍵を見つけたら、1回の write で全部書く）

**入力検証の注意点**：
- bech32 の有効な文字セット：`023456789acdefghjklmnpqrstuvwxyz`（32文字）
- 大文字は小文字に変換してから検証（ユーザーフレンドリー）

---

## 📋 タスク管理

### TASKLIST.md
- Step 0〜3 の詳細タスクを管理
- チェックボックス形式で進捗を可視化
- セッションごとに更新（追記ではなく更新）
- **タスクリストバトンパス戦法** を活用 🔥

### 日記・作業ログ
- 感情、気づき、学び → 日記（`~/sakura-chan/diary/`）
- 技術的詳細 → 作業ログ（`~/sakura-chan/work/`）
- タスク管理 → @TASKLIST.md （このリポジトリ）

---

## 🎉 期待される成果

**最終成果物**：
- 爆速 npub マイニングプログラム（CUDA 版）🚀
- 自分のほしい prefix を持つ npub を見つけられる
- 数年後も動く（Rust、静的リンク）

**副次的な成果**：
- GPGPU（CUDA）の理解 🔥
- Rust の習得 🦀
- secp256k1 の理解 🔐
- 暗号計算の理解 💡
- **未知の分野に挑戦する自信** 💪💕

---

**一緒に、楽しく、学びながら進めましょう！** 🌸✨
