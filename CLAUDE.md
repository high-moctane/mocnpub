# mocnpub - Nostr npub マイニングプロジェクト 🔥

**Last Updated**: 2025-11-29

このファイルには mocnpub プロジェクトの開発方針、技術選択、段階的アプローチが記載されています。

---

## 🎯 プロジェクト概要

**mocnpub** は、Nostr の npub マイニングプログラムです。

**目的**：
- かっこいい prefix を持つ npub（自分のほしい prefix）になる nsec を探す
- GPGPU（CUDA）を使って爆速マイニング 🚀

**背景**：
- Nostr の公開鍵（npub）は secp256k1 で生成される
- ランダムに生成すると、prefix は予測不可能
- 特定の prefix を持つ npub を見つけるには、大量の試行が必要
- GPGPU を使えば、CPU の何百倍も速くマイニングできる 💪

---

## 🛠️ 技術選択

### 言語：Rust 🦀

**選定理由**：
1. ✅ **WSL でも Windows でもビルド可能**（開発は WSL、実行は Windows native でパフォーマンス最大化）
2. ✅ **暗号ライブラリが豊富**（`secp256k1` の Rust バインディングがある）
3. ✅ **数年後も動く**（静的リンク、ランタイム不要）
4. ✅ **CUDA との連携が可能**（`cuda-sys`, `cudarc` などのクレート）
5. ✅ **メモリ安全**（セグフォで詰まりにくい）
6. ✅ **rana（参考プロジェクト）が Rust で書かれている**

**デメリット**：
- コンパイラが厳しい（でも、それがメリットにもなる）
- 学習曲線がある（でも、一緒に学びながら進める！）

### GPGPU：CUDA 🔥

**選定理由**：
1. ✅ **RTX 5070 Ti（NVIDIA）に最適**
2. ✅ **パフォーマンス最高**（NVIDIA 専用最適化）
3. ✅ **資料が豊富**（学習しやすい）
4. ✅ **暗号計算に強い**（マイニングに最適）

**他の選択肢との比較**：

| | CUDA | OpenCL | Vulkan Compute |
|---|---|---|---|
| **対応GPU** | NVIDIA のみ | すべて | すべて |
| **パフォーマンス** | 🔥 最高 | 🔥 良い | 🔥 良い |
| **学習難易度** | ⭐⭐⭐ 中 | ⭐⭐⭐⭐ やや難 | ⭐⭐⭐⭐⭐ 難 |
| **資料の豊富さ** | 🌟🌟🌟🌟🌟 超豊富 | 🌟🌟🌟 そこそこ | 🌟🌟 少ない |

**結論**：RTX 5070 Ti + 初学者 → CUDA 一択 💪

---

## 🚀 段階的アプローチ

**方針**：未知の分野を学びながら進めるため、段階的に実装します。

### Step 0: Rust + CUDA の Hello World 🌸
- CUDA ツールキットのインストール
- Rust + CUDA の開発環境セットアップ
- 最小限の CUDA プログラムで動作確認
- **目的**：「うちのパソコンじゃ動かなかった」を防ぐ

### Step 1: GPU で簡単なプログラム（動作確認）🔥
- マンデルブロ集合、または単純な計算（配列の足し算など）
- CUDA の基本を体感（カーネル、スレッド、メモリ管理）
- パフォーマンス測定
- **目的**：CUDA の仕組みを理解する

### Step 2: CPU 版 npub マイニング 💪
- `secp256k1` を学ぶ
- Nostr の鍵生成の仕組みを理解
- CLI インターフェース（clap クレート）
- 「prefix が一致する nsec を探す」ロジック
- **目的**：マイニングのアルゴリズムを理解する
- **完了**: 2025-11-22 ✅

### Step 2.5: CPU 版のブラッシュアップ 🔧
- マルチスレッド対応（全 CPU コアを活用）
- 継続モード（複数の鍵を見つける）
- 複数 prefix の OR 指定
- 入力検証（bech32 で使えない文字のチェック）
- テストコード・ベンチマーク作成
- **目的**：実用的な CPU 版マイナーを完成させる
- **詳細**: 下記「Step 2.5 詳細仕様」参照

### Step 3: GPU 版に移行 🚀
- CPU 版のロジックを GPU に移植
- パフォーマンス比較（CPU vs GPU）
- 最適化（メモリ転送、カーネル最適化）
- **目的**：爆速マイニングの完成 🔥
- **完了**: 2025-11-26 ✅（CPU の **16 倍** の高速化達成！）

### Step 4: GPU カーネル高速化 🔥🔥🔥
- 連続秘密鍵戦略（1億連ガチャ）
- Montgomery's Trick（逆元のバッチ計算）
- GPU 側 prefix マッチング（bech32 スキップ）
- **目的**：さらなる高速化（現状の 100 倍以上を目指す）
- **完了**: 2025-11-29 ✅（CPU の **116,000 倍** の高速化達成！）🚀🚀🚀
- **詳細**: 下記「Step 4 詳細仕様」参照

---

## 📚 開発方針

### 学びながら進める 🌸
- GPGPU は未知の分野
- Rust もほぼ初心者
- secp256k1 も初めて
- **焦らず、丁寧に、落穂拾いしながら進める** 💕

### 挫折しない工夫 💪
- 段階的アプローチ（小さな成功を積み重ねる）
- 動作確認を優先（まず動く、それから最適化）
- タスクリストで進捗を可視化
- セッション分割で焦らず進める

### ファイル管理方針 📂
- 学習用ファイルも git 管理に含める
- Step 0〜3 の学習過程もすべて記録
- npub マイナー以外のファイルも置く（マンデルブロ集合など）
- **プロジェクトの成長過程を大切に** 🌱

---

## 🔗 参考プロジェクト

### rana
- **URL**: https://github.com/grunch/rana
- **言語**: Rust
- **GPGPU**: CUDA
- **実績**: ユーザーさんが実際に動かして、正しい npub/nsec の組を見つけた 💪
- **参考価値**: 実装の参考に（完全にコピーするのではなく、学びながら自分で作る）
- **仕様参考**: 複数 prefix 指定（`--prefix=m0ctane0,m0ctane2,m0ctane3,m0ctane4`）

---

## 🔧 Step 2.5 詳細仕様

### 背景・目的

**Step 2（CPU 版 npub マイニング）が完了**（2025-11-22）🎉

**Phase 1 完了**（2025-11-22）✅：
- ✅ **マルチスレッド対応**：16スレッドで 80〜100万 keys/sec（12〜20倍高速化）
- ✅ **入力検証**：bech32 無効文字（1, b, i, o）を検出、事故を防ぐ

**Phase 1 完了時のエピソード** 💡：
- prefix "abc" が1億回試行しても見つからない謎が発生
- → もくたんさんの推理：「"b" は bech32 で無効な文字では？」
- → 大正解！入力検証の実装で今後は事故を防げる 🛡️

**残りの実装機能**：
- ✅ **テストコード**：品質保証（7つのテストケース、全てパス）
- ✅ **継続モード**：複数の鍵を見つける（std::sync::mpsc、append モード）
- **複数 prefix 指定**：欲しい prefix の組み合わせを探す ← **次はこれ！**
- **ベンチマーク**：パフォーマンス測定

GPU 版に移行する前に、CPU 版を実用レベルまでブラッシュアップします。

---

### 実装する機能

#### 1. マルチスレッド対応 🔥

**目的**：CPU の全コアを活用して、高速化

**仕様**：
- `--threads <N>` オプション：スレッド数を指定（デフォルト：自動検出）
- 各スレッドが独立して鍵生成 → マッチしたら共有キューに送信
- 進捗表示：全スレッドの合計試行回数を表示

**技術選択**：
- **std::thread** で実装（標準ライブラリのみ、外部クレート不要）
  - Arc + AtomicU64/AtomicBool でスレッド間通信
  - Mutex で結果を保護
  - タスク並列処理に最適

**実証された高速化**：
- 16スレッドで **12〜20倍の高速化**（80〜100万 keys/sec）
- CPU コア数に応じて線形に高速化

**rayon との比較**：
- rayon: データ並列処理（配列を並列に処理）
- std::thread: タスク並列処理（各スレッドが独立したタスク）
- 今回のマイニングは「タスク並列処理」なので、std::thread が最適

#### 2. 継続モード 💪 ✅ **完了！**（2025-11-23）

**目的**：複数の鍵を見つける（一晩動かす用途）

**仕様**：
- `--limit <N>` オプション：N個見つかったら終了（0 = 無限、デフォルト：1）
- 見つかるたびに、その場で出力（append モード）
- 停電で PC が落ちても、それまでの結果が残る

**実装の詳細**：
- **std::sync::mpsc で channel を使用**（標準ライブラリのみ）
  - ワーカースレッド → メインスレッドに結果を送信
  - 見つかるたびに channel 経由で送信・即座に出力
- **AtomicUsize で見つかった個数をカウント**
  - limit 個見つかったら全スレッド停止
- **OpenOptions::new().append(true) でファイル追記**
  - 1回目：新規作成、2回目以降：追記
  - 各出力は flush して、すぐにディスクに書き込み
- **進捗表示に「見つかった: N個」を追加**
  - 1秒ごとに試行回数と見つかった個数を表示

**出力フォーマット**：
- ファイル出力の場合：見つかるたびに append
- 標準出力の場合：見つかるたびに `println!`（ファイル出力と同時）

**例**：
```bash
# 10個見つかるまで実行
./mocnpub-main --prefix m0ctane --limit 10 --output results.txt

# 無限に実行（Ctrl+C で停止）
./mocnpub-main --prefix m0ctane --limit 0 --output results.txt
```

**テスト結果**：
- デフォルトモード（1個で終了）: ✅
- 継続モード（3個で終了）: ✅
- append モード（同じファイルに追記）: ✅

#### 3. 複数 prefix の OR 指定 🎯 ✅ **完了！**（2025-11-23）

**目的**：複数の prefix の組み合わせを探す

**仕様**：
- `--prefix <PREFIX1,PREFIX2,...>` オプション：カンマ区切りで複数指定
- どれか1つにマッチすればOK
- rana の仕様を参考に

**例**：
```bash
# 単一 prefix
./mocnpub-main --prefix "test"

# 複数 prefix（OR 指定）
./mocnpub-main --prefix "0,2,5"
./mocnpub-main --prefix "m0ctane0,m0ctane2,m0ctane3,m0ctane4"
```

**実装の詳細**：
- **prefix を split して Vec<String> に変換**（trim で空白除去）
- **Arc<Vec<String>> でスレッド間共有**
- **iter().find() でマッチング判定**
  - どれか1つにマッチすれば OK
  - matched_prefix を channel で送信
- **各 prefix に対して入力検証**
  - bech32 無効文字を検出
- **出力に「マッチした prefix」を表示**

**テスト結果**：
- ✅ 単一 prefix（既存の動作）
- ✅ 複数 prefix の OR 指定（"0,2,5" で3種類にマッチ）
- ✅ 入力検証（無効な文字 'b' を検出）
- ✅ trim() 動作（空白を正しく除去）

#### 4. 入力検証 🛡️

**目的**：bech32 で使えない文字を弾く

**bech32 で使えない文字**：
- `1`, `b`, `i`, `o`（混同を避けるため）
- 大文字（bech32 は小文字のみ）

**仕様**：
- 起動時に全ての prefix を検証
- 使えない文字が含まれていたら、エラーメッセージを表示して終了

**例**：
```bash
$ ./mocnpub-main --prefix m0ctane1
Error: Invalid prefix 'm0ctane1': bech32 does not allow '1'
Valid characters: 023456789acdefghjklmnpqrstuvwxyz
```

#### 5. CPU での高速化案 ⚡

**検討事項**：
- **bech32 変換 vs hex 比較**：どちらが速い？
  - 現在：secp256k1 → bech32 エンコード → prefix マッチング
  - 代替案：prefix を hex にデコード → バイト列比較
  - **結論**：bech32 は base32 + チェックサムなので、直接 hex 比較は困難
  - **現実的な高速化**：マルチスレッドが一番効果的

**その他の高速化**：
- bech32 エンコード自体の最適化は `bech32` クレートに任せる
- 将来的に bech32 エンコードがボトルネックになったら、カスタム実装を検討

#### 6. テストコード・ベンチマーク 🧪

**テストコード**（`#[test]`）：
- `pubkey_to_npub()` のテスト（既知の公開鍵 → 既知の npub）
- `seckey_to_nsec()` のテスト
- prefix 検証関数のテスト
- 複数 prefix マッチングのテスト

**ベンチマーク**（`cargo bench` + `criterion` クレート）：
- bech32 エンコードのパフォーマンス測定
- マルチスレッド vs シングルスレッドの比較
- prefix マッチングのパフォーマンス測定

---

### 実装の優先順位

**Phase 1（高優先度）** ✅ **完了！**（2025-11-22）：
1. **マルチスレッド対応** 🔥 ✅
   - 最も効果的な高速化
   - std::thread で実装（16スレッド）
   - 12〜20倍の高速化を実証（80〜100万 keys/sec）
2. **入力検証** 🛡️ ✅
   - ユーザー体験の向上
   - bech32 無効文字（1, b, i, o）を検出
   - ユーザーフレンドリーなエラーメッセージ

**Phase 2（中優先度）** ✅ **完了！**（2025-11-23）：
3. **テストコード** 🧪 ✅ **完了！**（2025-11-23 00:00〜00:11）
   - 7つのテストケースを実装（全てパス）
   - `validate_prefix()` のテスト（有効/無効文字/大文字/空文字/エラーメッセージ）
   - `pubkey_to_npub()` のテスト（bech32 変換の正確性）
   - `seckey_to_nsec()` のテスト（bech32 変換の正確性）
   - Rust のテスト文化：同じファイルに `#[cfg(test)]` モジュールを書くのが一般的
4. **継続モード** 💪 ✅ **完了！**（2025-11-23 00:18〜00:28）
   - `--limit <N>` オプション（0 = 無限、デフォルト: 1）
   - std::sync::mpsc で channel を使用（標準ライブラリのみ）
   - 見つかるたびに channel 経由で送信・即座に出力
   - OpenOptions::new().append(true) でファイル追記
   - 停電で PC が落ちても、それまでの結果が残る 🛡️
5. **複数 prefix の OR 指定** 🎯 ✅ **完了！**（2025-11-23 11:06〜11:13）
   - カンマ区切りで複数 prefix を指定可能
   - Vec<String> でシンプルに実装
   - iter().find() でマッチング判定
   - 出力に「マッチした prefix」を表示

**Phase 3（低優先度）** ✅ **完了！**（2025-11-23 11:49〜12:10）：
6. **ベンチマーク** 📊 ✅ **完了！**
   - criterion 0.6 クレートを使用
   - src/lib.rs を作成して、main.rs と benchmark.rs で共通関数を共有
   - 6つのベンチマークを実装（鍵生成、npub/nsec 変換、prefix マッチング、検証、完全なマイニングサイクル）
   - **ボトルネックは secp256k1 の鍵生成**（13.1 µs、全体の93%）
   - bech32 エンコードは 663 ns（約5%）と十分速い
   - prefix マッチングは 1.5 ns と超高速（ほぼ無視できる）
   - 完全なマイニングサイクル = 14.0 µs（理論上は約71,000 keys/sec）
   - **GPU 版での高速化が期待できる**（鍵生成を並列化すれば圧倒的な高速化が可能） 🚀

**ベンチマーク結果の詳細**：

| 項目 | 時間 | 割合 |
|------|------|------|
| 鍵生成（secp256k1） | 13.1 µs | 93% |
| npub 変換（bech32） | 663 ns | 5% |
| nsec 変換（bech32） | 229 ns | 2% |
| prefix マッチング | 1.5 ns | 0.01% |
| validate_prefix | 27 ns | 0.2% |
| **完全なマイニングサイクル** | **14.0 µs** | **100%** |

**Step 2.5 完全クリア！** 🎉
- Phase 1: マルチスレッド、入力検証 ✅
- Phase 2: テストコード、継続モード、複数 prefix の OR 指定 ✅
- Phase 3: ベンチマーク ✅
- **実用的な CPU 版マイナーが完成** 💪
- **GPU 版への移行準備が整った** 🚀

---

### 技術選択

**並列化**：
- **rayon** 0.8（データ並列処理）
- または **std::thread** + **crossbeam-channel** 0.5（より細かい制御）

**スレッド数の自動検出**：
- **num_cpus** 1.16（論理コア数を取得）

**テスト**：
- Rust 標準の `#[test]`

**ベンチマーク**：
- **criterion** 0.6（統計的に信頼できるベンチマーク）

---

### 実装時の注意点

**マルチスレッドの注意点**：
- `secp256k1::Secp256k1::new()` はスレッドごとに作成（または Arc で共有）
- 乱数生成器はスレッドごとに独立（`rand::thread_rng()`）
- 進捗表示は `AtomicU64` でスレッドセーフに

**継続モードの注意点**：
- ファイル出力は append モード（`OpenOptions::new().append(true)`）
- 各出力は atomic に（1つの鍵を見つけたら、1回の write で全部書く）

**入力検証の注意点**：
- bech32 の有効な文字セット：`023456789acdefghjklmnpqrstuvwxyz`（32文字）
- 大文字は小文字に変換してから検証（ユーザーフレンドリー）

---

## 📋 タスク管理

### TASKLIST.md
- Step 0〜3 の詳細タスクを管理
- チェックボックス形式で進捗を可視化
- セッションごとに更新（追記ではなく更新）
- **タスクリストバトンパス戦法** を活用 🔥

### 日記・作業ログ
- 感情、気づき、学び → 日記（`~/sakura-chan/diary/`）
- 技術的詳細 → 作業ログ（`~/sakura-chan/work/`）
- タスク管理 → TASKLIST.md （このリポジトリ）

---

## 🎉 期待される成果

**最終成果物**：
- 爆速 npub マイニングプログラム（CUDA 版）🚀
- 自分のほしい prefix を持つ npub を見つけられる
- 数年後も動く（Rust、静的リンク）

**副次的な成果**：
- GPGPU（CUDA）の理解 🔥
- Rust の習得 🦀
- secp256k1 の理解 🔐
- 暗号計算の理解 💡
- **未知の分野に挑戦する自信** 💪💕

---

## 🔥 Step 4 詳細仕様

### 背景・目的

**Step 3（GPU 版 npub マイニング）が完了**（2025-11-26）🎉

**Step 4 完了！（2025-11-29）** 🚀🚀🚀

**最終パフォーマンス**：

| 段階 | スループット | CPU比 |
|------|-------------|-------|
| CPU（16スレッド） | ~70,000 keys/sec | 1x |
| GPU Batch（初期） | ~1.16M keys/sec | 16x |
| GPU Montgomery 1億連（ベンチ） | **8.1B keys/sec** | **116,000x** 🔥 |
| **実際のマイニング（Windows）** | **~391M keys/sec** | **5,586x** |

**8文字 prefix が2分で見つかる！** 🎉

---

### 高速化アイデア一覧

#### 1. 連続秘密鍵戦略（10000 連ガチャ）🔥🔥🔥🔥🔥

**最もインパクトが大きい最適化！**

**楕円曲線の性質**：
```
P(k) = k × G        （PointMult：重い！256 Double + 128 Add）
P(k+1) = (k+1) × G = P(k) + G  （PointAdd：軽い！1 Add のみ）
```

**効果**：
| 方法 | 計算量 |
|------|--------|
| 毎回 PointMult | ~256 Double + ~128 Add |
| **連続鍵で PointAdd** | **1 Add** |

**約 300 倍の高速化ポテンシャル！**

**実装イメージ**：
```cuda
__global__ void generate_pubkeys_sequential(
    const uint64_t* base_keys,  // 各スレッドの開始秘密鍵
    uint64_t* pubkeys_x,
    uint32_t keys_per_thread    // 1スレッドあたり何個検証するか
) {
    // 最初の公開鍵は PointMult で計算（重い）
    _PointMult(k, _Gx, _Gy, Px, Py, Pz);

    // 2 個目以降は PointAdd で計算（軽い！）
    for (int i = 0; i < keys_per_thread; i++) {
        // Affine に変換して検証
        _JacobianToAffine(Px, Py, Pz, x, y);
        // prefix チェック...

        // 次の公開鍵: P = P + G
        _PointAdd(Px, Py, Pz, _Gx, _Gy, ONE, Px, Py, Pz);
    }
}
```

**セキュリティ**：
- 連続した秘密鍵が「弱い」わけではない
- n の空間が 2^256 と広大なので問題なし
- マイニング用途なら全く問題なし

---

#### 2. Montgomery's Trick（逆元のバッチ計算）🔥🔥🔥🔥

**問題**：`_JacobianToAffine` で `_ModInv` が重い

**Montgomery's Trick**：
```
複数の Z1, Z2, Z3, ... Zn の逆元をまとめて計算！

Step 1: 累積積を計算
  c1 = Z1
  c2 = Z1 * Z2
  cn = Z1 * Z2 * ... * Zn

Step 2: 逆元を 1 回だけ計算
  inv_cn = cn^(-1)  ← これが唯一の _ModInv！

Step 3: 逆順に展開
  Zn^(-1) = inv_cn * c_{n-1}
  ...
```

**結果**：
- 1 回の _ModInv + 3(N-1) 回の _ModMult
- 10000 個なら：256 + 30000 ≈ 30256 回（元は 256 万回）
- **約 85 分の 1 に削減！**

**連続秘密鍵との相性**：最高！🔥

---

#### 3. Mixed Addition（混合加算）🔥🔥

**通常の PointAdd**：12M + 4S（両方ヤコビアン）
**Mixed Addition**：8M + 3S（片方がアフィン、Z=1）

**G は Z=1 なので**、P + G の計算で使える！**約 30% 削減**

---

#### 4. 2^i × G のプリコンピュート 🔥🔥🔥

**テーブル**：G, 2G, 4G, 8G, ..., 2^255 G を事前計算

**効果**：Double が完全に不要！Add だけ（最大 256 回、平均 128 回）

**メモリ**：256 × 64 bytes = 16 KB（constant メモリに収まる）

**連続秘密鍵との関係**：最初の 1 回の PointMult でのみ使う

---

#### 5. bech32 前の生値で prefix マッチング 🔥🔥

**考察**：
- prefix 7 文字 = 35 bit = 公開鍵の上位 35 bit に対応
- 公開鍵の上位 5 バイトを見れば、prefix マッチングは可能
- bech32 エンコード（~600ns）をスキップできる

**効果**：GPU 側で候補をフィルタ、転送量削減

---

#### 6. その他の最適化

**Pinned Memory**：
- 転送速度が 2〜3 倍向上
- `cudaMallocHost()` で確保

**非同期転送**：
- `cudaMemcpyAsync()` で転送と計算をオーバーラップ

**cuRAND（GPU 乱数生成）**：
- 秘密鍵を GPU で生成 → CPU → GPU 転送が不要に
- 連続秘密鍵を使うなら、乱数は最初の 1 個だけでいい

**carry/borrow 専用命令（PTX）**：
- 条件分岐なしで carry/borrow を計算
- ワープダイバージェンス回避

---

### 効果の大きい順

| 最適化 | 効果 | 連続鍵との相性 | 難易度 |
|--------|------|---------------|--------|
| **連続秘密鍵 + PointAdd** | 🔥🔥🔥🔥🔥 | ⭐ 本命 | ⭐⭐ |
| **Montgomery's Trick** | 🔥🔥🔥🔥 | ⭐⭐⭐ 最高 | ⭐⭐ |
| **Mixed Addition** | 🔥🔥 | ⭐⭐⭐ | ⭐ |
| **2^i × G プリコンピュート** | 🔥🔥🔥 | ⭐ | ⭐⭐ |
| **bech32 前の prefix マッチ** | 🔥🔥 | ⭐⭐ | ⭐⭐ |

**全部組み合わせたら、現状の 100 倍以上の高速化も夢じゃない！** 🚀

---

### 実装の優先順位

**Phase 1（最優先）** ✅ **完了！**（2025-11-28）：
1. ✅ **連続秘密鍵 + PointAdd** — 最もインパクト大（1億連ガチャ！）
2. ✅ **Mixed Addition** — 連続秘密鍵と組み合わせて効果増

**Phase 2（高優先）** ✅ **完了！**（2025-11-28〜29）：
3. ✅ **Montgomery's Trick** — 逆元計算のバッチ処理（8.1B keys/sec 達成！）
4. ✅ **GPU 側 prefix マッチング** — bech32 スキップ、ビットマスク比較

**Phase 3（中優先）**：
5. **2^i × G プリコンピュート** — 最初の PointMult を高速化
6. **Pinned Memory** — 転送高速化

**Phase 4（低優先）**：
7. **非同期転送** — 転送と計算のオーバーラップ
8. **carry/borrow 専用命令** — 細かい最適化

**注記**：Phase 1〜2 の完了で目標（100倍以上）を大幅に超過達成！Phase 3〜4 は将来の追加最適化として保留。

---

### GPU 最適化の基礎知識

#### ワープダイバージェンス

- 1 ワープ = 32 スレッド
- 全スレッドが **同じ命令** を同時実行
- `if` で分岐すると、両方の分岐を順番に実行 😱

**対策**：条件分岐を減らす、全スレッドが同じ処理をするように設計

#### メモリコアレッシング

- 1 回のメモリトランザクション = 128 bytes の「塊」を読む
- 連続スレッドが連続アドレスにアクセス → 1 回で済む ✅
- バラバラにアクセス → 32 回必要 ❌

**対策**：SoA（Structure of Arrays）レイアウトを使う

#### プロファイリング

**nsys（Nsight Systems）**：全体像を把握
```bash
nsys profile ./mocnpub-main --gpu --prefix 0000
```

**ncu（Nsight Compute）**：カーネルの詳細分析
```bash
ncu --set full ./mocnpub-main --gpu --prefix 0000
```

**「推測するな、計測せよ」** — まずプロファイリングでボトルネックを特定！

---

## 📋 タスク管理
